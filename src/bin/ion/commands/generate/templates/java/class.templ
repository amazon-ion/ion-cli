{# Includes the macros for anonymous types that will be added as child classes #}
{% import "nested_type.templ"  as macros %}
{% import "util_macros.templ"  as util_macros %}

{% macro class(model, is_nested) %}

{% if is_nested == false %}
{% set full_namespace = namespace | join(sep=".") %}

package {{ full_namespace }};
import com.amazon.ion.IonReader;
import com.amazon.ion.IonException;
import com.amazon.ion.IonWriter;
import com.amazon.ion.IonType;
import java.io.IOException;
{% endif %}


{# Verify that the abstract data type is a structure and store information for this structure #}
{% set struct_info = model.code_gen_type["Structure"] %}

{% if is_nested == true %} static {% endif %} class {{ model.name }} {
    {% for field_name, field_value in struct_info["fields"] -%}
           private {{ field_value.0 | fully_qualified_type_name }} {{ field_name | camel }};
    {% endfor %}

    public {{ model.name }}() {}

    {% for field_name, field_value in struct_info["fields"] -%}public {{ field_value.0 | fully_qualified_type_name }} get{% filter upper_camel %}{{ field_name }}{% endfilter %}() {
        return this.{{ field_name | camel }};
    }
    {% endfor %}

    {% for field_name, field_val in struct_info["fields"] %}
        {% set field_value = field_val.0 %}
        {% set val = field_value | fully_qualified_type_name %}
        {% if val is containing("NestedType") %}
          public void set{% filter upper_camel %}{{ field_name }}{% endfilter %}(
          {{ macros::define_params_for_anonymous_type(nested_type=val, type_store=type_store, field_name=field_name, initial_field_name=field_name) }}
          ) {
          {{ macros::initialize_anonymous_type(nested_type=val, type_store=type_store, field_name=field_name) }}
          this.{{ field_name | camel }} = {{ field_name | camel }};
          return;
        {% else %}
        public void set{% filter upper_camel %}{{ field_name }}{% endfilter %}({{ val }} {{ field_name | camel }}) {
            this.{{ field_name | camel }} = {{ field_name | camel }};
            return;
        {% endif %}
    }
    {% endfor %}


    /**
     * Reads a {{ model.name }} from an {@link IonReader}.
     *
     * This method does not advance the reader at the current level.
     * The caller is responsible for positioning the reader on the value to read.
     */
    public static {{ model.name }} readFrom(IonReader reader) {
        {# Initializes all the fields of this class #}
        {% for field_name, field_val in struct_info["fields"] -%}
            {% set field_value = field_val.0 | fully_qualified_type_name %}
            {% set field_occurrence = field_val.1 %}
            {# Initialize all the required fields as `java.util.Optional` to verify if the required fields were missing or not #}
            java.util.Optional<{{ field_value | wrapper_class }}> {{ field_name | camel }} = java.util.Optional.empty();
        {% endfor %}

        {# Reads `Structure` class with multiple fields based on `field.name` #}
        reader.stepIn();
        while (reader.hasNext()) {
            reader.next();
            String fieldName = reader.getFieldName();
            switch(fieldName) {
                {% for field_name, field_val in struct_info["fields"] %}
                {% set field_value = field_val.0 | fully_qualified_type_name %}
                {% set field_occurrence = field_val.1 %}
                {% if field_occurrence == "Optional" %} {% set field_value = field_value | primitive_data_type %} {% endif %}
                case "{{ field_name }}":
                    {{ field_name | camel }} =  java.util.Optional.of(
                                                {% if field_value | is_built_in_type %}
                                                   {% if field_value == "bytes[]" %}
                                                        reader.newBytes()
                                                   {% else %}
                                                        reader.{{ field_value | camel }}Value()
                                                   {% endif %}
                                                {% elif field_value is containing("ArrayList") %}
                                                   {{ util_macros::read_as_sequence(field_value=field_value,field_name=field_name,type_store=type_store, field_occurrence=field_occurrence) }}
                                                {% else %}
                                                    {{ field_value }}.readFrom(reader)
                                                {% endif %});
                    break;
                {% endfor %}
                default:
                    throw new IonException("Can not read field name:" + fieldName + " for {{ model.name }} as it doesn't exist in the given schema type definition.");
            }
        }
        reader.stepOut();

        {{ model.name }} {{ model.name | camel }} = new {{ model.name }}();
        {% for field_name, field_val in struct_info["fields"] -%}
            {% set field_value = field_val.0 | fully_qualified_type_name %}
            {% set field_occurrence = field_val.1 %}
            {% if field_occurrence == "Required" %}
            // Verify if the required field was initialized
            if (!{{ field_name | camel }}.isPresent()) {
                throw new IonException("Can not find field name: {{ field_name }} for {{ model.name }} while reading Ion data.");
            } else {
                {{ model.name | camel }}.{{ field_name | camel }} = {{ field_name | camel }}.get();
            }
            {% else %}
            if (!{{ field_name | camel }}.isPresent()) {
                // sets optional field as null when not present
                {{ model.name | camel }}.{{ field_name | camel }} = null;
            } else {
                {{ model.name | camel }}.{{ field_name | camel }} = {{ field_name | camel }}.get();
            }
            {% endif %}
        {% endfor %}

        return  {{ model.name | camel }};
    }

    /**
     * Writes a {{ model.name }} as Ion from an {@link IonWriter}.
     *
     * This method does not close the writer after writing is complete.
     * The caller is responsible for closing the stream associated with the writer.
     * This method skips writing a field when its null.
     */
    public void writeTo(IonWriter writer) throws IOException {
         {# Writes `Structure` class with multiple fields based on `field.name` as an Ion struct #}
         writer.stepIn(IonType.STRUCT);
         {% for field_name, field_val in struct_info["fields"] %}
             {% set field_value = field_val.0 | fully_qualified_type_name %}
             {% set field_occurrence = field_val.1 %}
             {% if field_occurrence == "Optional" %}
                {% set field_value = field_value | primitive_data_type %}
                if (this.{{ field_name | camel }} != null) {
             {% endif %}
             writer.setFieldName("{{ field_name }}");
             {% if field_value | is_built_in_type == false %}
                {% if field_value is containing("ArrayList") %}
                    {{ util_macros::write_as_sequence(field_value=field_value,field_name=field_name,type_store=type_store) }}
                {% else %}
                    this.{{ field_name | camel }}.writeTo(writer);
                {% endif %}
             {% else %}
                 writer.write{{ field_value | replace(from="double", to="float") | replace(from="boolean", to="bool") | upper_camel }}(this.{{ field_name | camel }});
             {% endif %}
             {% if field_occurrence == "Optional" %}
                }
             {% endif %}
         {% endfor %}
         writer.stepOut();
    }

    {% for inline_type in model.nested_types -%}
        {% set is_nested = true %}
        {{ macros::nested_type(model=inline_type, is_nested=is_nested) }}
    {% endfor -%}
}
{% endmacro model %}
{{ self::class(model=model, is_nested=is_nested) }}