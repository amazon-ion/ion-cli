{% macro sequence(model) %}

{# Verify that the abstract data type is a sequence type and store information for this sequence value #}
{% set sequence_info = model.code_gen_type["WrappedSequence"] %}

class {{ model.name }} {
    private java.util.ArrayList<{{ sequence_info["element_type"] | to_string }}> value;

    public {{ model.name }}() {}

    public java.util.ArrayList<{{ sequence_info["element_type"] | to_string }}> getValue() {
        return this.value;
    }

    public void setValue(java.util.ArrayList<{{ sequence_info["element_type"] | to_string }}> value) {
        this.value = value;
        return;
    }

    /**
     * Reads a {{ model.name }} from an {@link IonReader}.
     *
     * This method does not advance the reader at the current level.
     * The caller is responsible for positioning the reader on the value to read.
     */
    public static {{ model.name }} readFrom(IonReader reader) {
        {# Initializes all the fields of this class #}
        java.util.ArrayList<{{ sequence_info["element_type"] | to_string }}> value = new java.util.ArrayList<{{ sequence_info["element_type"] | to_string }}>();
        {# Reads `Sequence` class with a single field `value` that is an `ArrayList` #}
         if(reader.getType() != IonType.{{ sequence_info["sequence_type"] | upper }}) {
            throw new IonException("Expected {{ sequence_info["sequence_type"] }}, found " + reader.getType() + " while reading value.");
         }
        reader.stepIn();
        {# Iterate through the `ArrayList` and read each element in it based on the data type provided in `sequence_info["sequence_type"]` #}
        while (reader.hasNext()) {
            reader.next();
            {% if sequence_info["element_type"] |to_string | is_built_in_type == false %}
                value.add({{ sequence_info["element_type"] | to_string }}.readFrom(reader));
            {% elif sequence_info["element_type"] | to_string == "bytes[]" %}
                value.add(reader.newBytes());
            {% else %}
                value.add(reader.{{ sequence_info["element_type"] | to_string | camel }}Value());
            {% endif %}
        }
        reader.stepOut();
        {{ model.name }} {{ model.name | camel }} = new {{ model.name }}();
        {{ model.name | camel }}.value = value;

        return  {{ model.name | camel }};
    }

    /**
     * Writes a {{ model.name }} as Ion from an {@link IonWriter}.
     *
     * This method does not close the writer after writing is complete.
     * The caller is responsible for closing the stream associated with the writer.
     */
    public void writeTo(IonWriter writer) throws IOException {
        {# Writes `Sequence` class with a single field `value` that is an `ArrayList` as an Ion sequence #}
        writer.stepIn(IonType.{{ sequence_info["sequence_type"] | upper }});
        for ({{ sequence_info["element_type"] | to_string }} value: this.value) {
             {% if sequence_info["element_type"] | to_string | is_built_in_type  == false %}
                value.writeTo(writer);
             {% else %}
                writer.write{{ sequence_info["element_type"] | to_string | replace(from="double", to="float") | replace(from="boolean", to="bool") | upper_camel }}(value);
             {% endif %}
        }
        writer.stepOut();
    }
}
{% endmacro %}
{{ self::sequence(model=model) }}